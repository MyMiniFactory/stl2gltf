<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
</head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-115758488-1"></script>
<script src="https://rawgit.com/Sphinxxxx/vanilla-picker/master/dist/vanilla-picker.min.js"></script>

<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-115758488-1');
</script>

<script async type="text/javascript" src="./a.out.js"></script>


<style>

#dragAndDrop {
    min-height: 200px;
    white-space: pre;
    border: 1px dashed black;
    border-radius: 10px;
}

#info {
    width:100%
    display: -webkit-flex;
    display: flex;
}

#picker {
    cursor: pointer;
}

</style>

<script type="text/javascript">
    `use strict`;

    let GLOBAL = {
        color : [150, 150, 150, 1],
        get color_str() {
            return `rgba(${this.color[0]},
            ${this.color[1]},
            ${this.color[2]},
            ${this.color[3]})`;
        },
        get color_0to1() {
            return [this.color[0]/255,
                    this.color[1]/255,
                    this.color[2]/255,
                    this.color[3]
            ];
        },
        info: undefined,
        boundary: undefined,
        stl_name: undefined
    };

    window.onload = function () {
        const init_color_str = GLOBAL.color_str;
        var picker_div = document.getElementById("picker");
        picker_div.style.backgroundColor = init_color_str;
        picker_div.style.color = init_color_str;
        var picker = new Picker(
            {
                parent: picker_div,
                alpha: false,
                color: init_color_str
            }
        );
        picker_div.onclick = function() {
            picker.show();
        };
        picker.onDone = function(color) {
            GLOBAL.color = color.rgba;
            picker_div.style.background = color.rgbaString;
            picker_div.style.color = color.rgbaString;
            download_glb();
        };
    }

    function uploaded(file) {
        if (file === undefined) { // via upload button
            var uploadform = document.getElementById("fileuploadform");
            file = uploadform.files[0];
        }

        check_file(file, function(){check_file_success()});

        function check_file_success() {

            put_status("Converting by your browser");

            var uploadform = document.getElementById("fileuploadform");
            var filename = file.name;
            var fr = new FileReader();
            fr.readAsDataURL(file);

            fr.onload = function (){
                var stl_name = filename;
                var number_indices = 0;
                let info = new Int32Array([
                    0, // number indices
                    0, // number vertices
                    0, // indices bytelength
                    0, // vertices bytelength
                    0  // total bytelength
                ]);
                var info_heapBytes = _arrayToHeap(info);

                let boundary = new Float32Array([
                    0.0,
                    0.0,
                    0.0,
                    0.0,
                    0.0,
                    0.0
                ]);
                var boundary_heapBytes = _arrayToHeap(boundary);

                var data = atob(fr.result.split(",")[1]); // base64 to Uint8 for emscripten
                Module['FS_createDataFile'](".", stl_name, data, true, true);

                Module.ccall("make_bin", // c function name
                        undefined, // return
                        ["string", "number", "number"], // param
                        [stl_name, info_heapBytes.byteOffset, boundary_heapBytes.byteOffset]
                );

                info = new Int32Array(info_heapBytes.buffer, info_heapBytes.byteOffset, info.length);
                boundary = new Float32Array(boundary_heapBytes.buffer, boundary_heapBytes.byteOffset, boundary.length);

                GLOBAL.info = info.slice();
                GLOBAL.boundary = boundary.slice();
                GLOBAL.stl_name = stl_name;

                download_glb();

                _freeArray(info_heapBytes);
                _freeArray(boundary_heapBytes);
            }
        }
    }

    function _arrayToHeap(typedArray){
        var numBytes = typedArray.length * typedArray.BYTES_PER_ELEMENT;
        var ptr = Module._malloc(numBytes);
        var heapBytes = new Uint8Array(Module.HEAPU8.buffer, ptr, numBytes);
        heapBytes.set(new Uint8Array(typedArray.buffer));
        return heapBytes;
    }
    function _freeArray(heapBytes){
        Module._free(heapBytes.byteOffset);
    }

    function Uint8ToString(u8a){
      var CHUNK_SZ = 0x8000;
      var c = [];
      for (var i=0; i < u8a.length; i+=CHUNK_SZ) {
          c.push(String.fromCharCode.apply(null, u8a.subarray(i, i+CHUNK_SZ)));
        }
        return c.join("");
    }

    function gltf_dict(
        total_blength, indices_blength, vertices_boffset, vertices_blength,
        number_indices, number_vertices, minx, miny, minz, maxx, maxy, maxz,
        color_r, color_g, color_b
    ) {
        return {
            "scenes" : [
                {
                    "nodes" : [ 0 ]
                }
            ],
            "nodes" : [
                {
                    "mesh" : 0,
                    "rotation": [-0.707, 0.0, 0.0, 0.707]
                }
            ],
            "meshes" : [
                {
                    "primitives" : [ {
                        "attributes" : {
                            "POSITION" : 1
                        },
                        "indices" : 0,
                        "material" : 0
                    } ]
                }
            ],
            "buffers" : [
                {
                    "byteLength" : total_blength
                }
            ],
            "bufferViews" : [
                {
                    "buffer" : 0,
                    "byteOffset" : 0,
                    "byteLength" : indices_blength,
                    "target" : 34963
                },
                {
                    "buffer" : 0,
                    "byteOffset" : vertices_boffset,
                    "byteLength" : vertices_blength,
                    "target" : 34962
                }
            ],
            "accessors" : [
                {
                    "bufferView" : 0,
                    "byteOffset" : 0,
                    "componentType" : 5125,
                    "count" : number_indices,
                    "type" : "SCALAR",
                    "max" : [ number_indices - 1 ],
                    "min" : [ 0 ]
                },
                {
                    "bufferView" : 1,
                    "byteOffset" : 0,
                    "componentType" : 5126,
                    "count" : number_vertices,
                    "type" : "VEC3",
                    "min" : [minx, miny, minx],
                    "max" : [maxx, maxy, maxz]
                }
            ],
            "asset" : {
                "version" : "2.0",
                 "generator": "STL2GLTF"
            },
            "materials": [
                {
                    "pbrMetallicRoughness": {
                        "baseColorFactor": [
                            color_r,
                            color_g,
                            color_b,
                            1
                            ],
                        "metallicFactor": 1,
                        "roughnessFactor": 1
                    }
                }
            ],
        } // end of dict
    }

    function download_glb() {

        if (GLOBAL.stl_name === undefined) {
            put_status("Please upload a file");
            return;
        } else {
        }

        const info = GLOBAL.info;
        const boundary = GLOBAL.boundary;
        const stl_name = GLOBAL.stl_name;
        const color = GLOBAL.color_0to1;

        const gltf_json = JSON.stringify(
            gltf_dict(info[4], info[2], info[2], info[3], info[0], info[1],
                      boundary[0], boundary[1], boundary[2],
                      boundary[3], boundary[4],boundary[5],
                      color[0], color[1], color[2]
            )
        );

        const out_bin_bytelength = info[4];

        const header_bytelength = 20;
        const scene_len = gltf_json.length;
        const padded_scene_len = ((scene_len+ 3) & ~3);
        const body_offset = padded_scene_len + header_bytelength;
        const file_no_bin_len = body_offset + 8;
        const file_len = file_no_bin_len + out_bin_bytelength;

        let glb = new Uint8Array(file_no_bin_len);
        glb[0] = 0x67; // g
        glb[1] = 0x6c; // l
        glb[2] = 0x54; // t
        glb[3] = 0x46; // f

        glb[4]  = ( 2 ) & 0xFF;
        glb[5]  = ( 2>>8 ) & 0xFF;
        glb[6] = ( 2>>16 ) & 0xFF;
        glb[7] = ( 2>>24 ) & 0xFF;

        glb[8]  = ( file_len ) & 0xFF;
        glb[9]  = ( file_len>>8 ) & 0xFF;
        glb[10] = ( file_len>>16 ) & 0xFF;
        glb[11] = ( file_len>>24 ) & 0xFF;
        glb[12] = ( padded_scene_len ) & 0xFF;
        glb[13] = ( padded_scene_len>>8 ) & 0xFF;
        glb[14] = ( padded_scene_len>>16 ) & 0xFF;
        glb[15] = ( padded_scene_len>>24 ) & 0xFF;

        // JSON
        glb[16] = 0x4A; // J
        glb[17] = 0x53; // S
        glb[18] = 0x4F; // O
        glb[19] = 0x4E; // N

        for (let i=0;i<gltf_json.length;i++) {
            glb[i+header_bytelength] = gltf_json.charCodeAt(i);
        }
        for (let i=0;i<padded_scene_len - scene_len;i++) {
            glb[i+scene_len+header_bytelength] = 0x20;
        }

        glb[body_offset  ] = ( out_bin_bytelength ) & 0xFF;
        glb[body_offset+1] = ( out_bin_bytelength>>8 ) & 0xFF;
        glb[body_offset+2] = ( out_bin_bytelength>>16 ) & 0xFF;
        glb[body_offset+3] = ( out_bin_bytelength>>24 ) & 0xFF;
        glb[body_offset+4] = 0x42; // B
        glb[body_offset+5] = 0x49; // I
        glb[body_offset+6] = 0x4E; // N
        glb[body_offset+7] = 0x00; //

        let out_bin = Module['FS_readFile']('out.bin');

        let blob = new Blob([glb, out_bin], {type: 'application/sla'});
        let url = window.URL.createObjectURL(blob);
        var download_a = document.getElementById('download');
        download_a.href = url;
        const glb_name = stl_name.slice(0,stl_name.length-4) + ".glb";
        download_a.download = glb_name;

        var download_button = document.getElementById('download_button');
        download_button.disabled = false;
        download_button.innerHTML = "Click to Download " + glb_name;
        download_button.click();

        if (blob.size < 3145728) {
            put_status("Success, you are now share it on facebook!")
        } else {
            put_status("Your stl file is too large, the GLB file is bigger than 3 Mb, cannot share on facebook.")
        }
    }

    function check_file(file, success_cb) {
        put_status("Checking file");
        const filename = file.name;
        const extension = filename.toLowerCase().slice(filename.lastIndexOf(".")+1, filename.length);
        if (extension!=="stl") {
            put_status("Please upload an stl file not "+ extension);
            return;
        }

        success_cb();
    }

    function dodrop(event) {
        var dt = event.dataTransfer;
        var file = dt.files[0];
        var filename = file.name;
        put_status("Converting " + filename + " to GLB using WebAssembly.");
        uploaded(file);
    }

    function put_status(text)
    {
        document.getElementById("status").textContent = text;
    }
</script>

<body>
    <h1>STL to GLB Converter</h1>
    <div id="dragAndDrop"
         ondragenter="event.stopPropagation(); event.preventDefault();"
         ondragover="event.stopPropagation(); event.preventDefault();"
         ondrop="event.stopPropagation(); event.preventDefault();
         dodrop(event);">
        <span>Drag and drop STL files here or <input type="file" onChange="uploaded()" id="fileuploadform"/></span>
        <span></span>
        <span>Click to change color --> <span id="picker">COLOR</span></span>
        <span></span>
        <span>Status: <span id="status">Waiting for upload</span>
    </div>
    <a id="download"><button id="download_button" disabled>Click to Download</button></a>
    <div id="info">
        <div>
            <h3>Note</h3>
            <ul>
                <li>Browser Based (WebAssembly), No Backend</li>
                <li>Facebook has a 3 Mb limit for GLB, make sure your stl is smaller than 8 Mb</li>
                <li>Work with ASCII/Binary stl less than 45 Mb</li>
            </ul>
        </div>
        <div>
            <h3>Upcoming features</h3>
            <ul>
                <li><a href="https://github.com/sp4cerat/Fast-Quadric-Mesh-Simplification">WASM Mesh Simplification</a> if stl file is too big to share</li>
                <li>Tell me on tiger AT myminifactory dotcom...</li>
                <li>Done <strike>Support for ASCII</strike></li>
                <li>Done <strike>Face Color Picker</strike> (Suggested by Mark)</li>
            </ul>
        </div>
    </div>

    <a href="https://github.com/MyMiniFactory/stl2gltf"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" alt="Fork me on GitHub"></a>
</body>

</html>
